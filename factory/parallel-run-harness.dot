// parallel-run-harness.dot — Ingest a requirements prompt via kilroy attractor ingest
// to generate a DOT pipeline, then run it. Each instance does its own ingest+run
// so the DOT-generation is stress-tested alongside the pipeline execution.
//
// The goal should be the path to the requirements prompt file (relative to the
// kilroy repo root), e.g.:
//   demo/rogue/rogue-prompt.txt
//
// Run: ./start .kilroy/repos/kilroy/factory/parallel-run-harness.dot "demo/rogue/rogue-prompt.txt"
//
// NOTE: The run config's stall_timeout_ms must be >= the longest expected child run duration.
// stall_timeout_ms: 0 disables the stall watchdog entirely.
//
// The run-rogue-ingest-instance.sh script is at:
//   $KILROY_SCRIPTS_DIR/run-rogue-ingest-instance.sh
// with fallback:
//   /workspace/project/.kilroy/repos/kilroy/scripts/run-rogue-ingest-instance.sh

digraph ParallelRunHarness {
  graph [
    goal="__GOAL__",
    rankdir=TB,
    model_stylesheet="
      * { llm_provider: google; llm_model: gemini-2.0-flash; }
      #analyze { llm_model: gemini-2.5-pro-preview-05-06; }
    "
  ]

  start [shape=Mdiamond]
  exit  [shape=Msquare]

  // ============================================================
  // Phase 1: Ingest prompt -> generate DOT -> run pipeline
  // ============================================================

  run_1 [
    shape=parallelogram,
    label="Ingest + Run 1",
    timeout="7200s",
    tool_command="bash -c '\"${KILROY_SCRIPTS_DIR:-/workspace/project/.kilroy/repos/kilroy/scripts}/run-rogue-ingest-instance.sh\" 1'"
  ]

  // ============================================================
  // Phase 2: Analyze results (runs regardless of run_1 outcome)
  // ============================================================

  analyze [
    shape=box,
    auto_status=true,
    max_agent_turns=15,
    prompt="You are the ANALYSIS AGENT for an ingest+run stress test. One instance has completed.\n\nRead these files:\n1. .kilroy/run_1_meta.json — metadata (instance, start/end times, status, exit code, generated_dot path)\n2. .kilroy/run_1_generated.dot — the DOT pipeline generated from the requirements prompt\n3. .kilroy/run_1_output.txt — full combined output from the ingest and run phases\n\nAssess the following:\n1. Ingest phase: was a valid DOT file generated? (read run_1_generated.dot — does it parse as a valid digraph?)\n2. Generated pipeline: what is the graph name and overall structure? Summarize what the pipeline would do.\n3. Run phase: did the generated pipeline execute successfully? (check status field in run_1_meta.json)\n4. Failures: if anything failed, extract the most relevant error lines from run_1_output.txt\n\nWrite .kilroy/ingest-run-report.md with these sections:\n\n## Executive Summary\nOne-sentence verdict: did the full ingest to run pipeline succeed end-to-end?\n\n## Ingest Phase\n- Status: success/fail\n- Generated DOT graph name (from digraph Name declaration)\n- Node count and key phases identified in the generated pipeline\n\n## Run Phase\n- Status: success/fail\n- Duration (started_at to ended_at from meta.json)\n- If failed: failure reason and relevant error excerpts from output\n\n## Assessment\n- Does the ingest+run pattern work end-to-end for this prompt?\n- What would need to change to make it work reliably?\n- Are there any structural issues in the generated DOT?\n\nWrite status to $KILROY_STAGE_STATUS_PATH:\n{\n  \"status\": \"success\",\n  \"context_updates\": {\n    \"ingest_succeeded\": <true|false>,\n    \"run_succeeded\": <true|false>,\n    \"report_path\": \".kilroy/ingest-run-report.md\"\n  }\n}"
  ]

  // ============================================================
  // Edges
  // ============================================================

  start -> run_1

  // Always go to analyze regardless of run_1 outcome.
  run_1 -> analyze
  run_1 -> analyze  [condition="outcome=fail", label="run failed - analyze anyway"]

  analyze -> exit
}
