digraph rogue_fast_regen {
    graph [
        goal="Port the classic Rogue 5.4.4 game from C to Rust/WASM, playable in a browser via a single HTML page with classic ASCII terminal rendering — exact mechanical port of all game systems, compiled to WebAssembly and served from demo/rogue/rogue-wasm/www/index.html",
        rankdir=LR,
        default_max_retry=3,
        retry_target="impl_integration_loop",
        fallback_retry_target="impl_wasm_frontend",
        default_command_timeout_ms=300000,
        max_command_timeout_ms=1800000,
        provenance_version="1",
        provenance_file_1="path=demo/rogue/original-rogue;git_sha=9673c3a4",
        provenance_file_2="path=demo/rogue/rogue_fast.dot;git_sha=9673c3a4",
        model_stylesheet="
            * { llm_model: zai-glm-4.7; llm_provider: cerebras; }
            .hard { llm_model: zai-glm-4.7; llm_provider: cerebras; }
            .verify { llm_model: zai-glm-4.7; llm_provider: cerebras; }
            .review { llm_model: zai-glm-4.7; llm_provider: cerebras; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]

    // =========================================================================
    // Toolchain readiness gate
    // =========================================================================

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="bash -lc 'set -euo pipefail; command -v cargo >/dev/null || { echo \"missing required tool: cargo (install via rustup.rs)\" >&2; exit 1; }; command -v rustup >/dev/null || { echo \"missing required tool: rustup (install via rustup.rs)\" >&2; exit 1; }; command -v wasm-pack >/dev/null || { echo \"missing required tool: wasm-pack (install with: cargo install wasm-pack)\" >&2; exit 1; }; rustup target list --installed | grep -qx wasm32-unknown-unknown || { echo \"missing required rust target: wasm32-unknown-unknown (install with: rustup target add wasm32-unknown-unknown)\" >&2; exit 1; }; echo \"toolchain OK: cargo=$(cargo --version), wasm-pack=$(wasm-pack --version), wasm32 target installed\"'"
    ]

    // =========================================================================
    // Phase 1: Spec expansion — bootstrap .ai/spec.md
    // =========================================================================

    expand_spec [
        shape=box,
        auto_status=true,
        max_agent_turns=40,
        prompt="You are bootstrapping a spec for porting Rogue 5.4.4 from C to Rust/WASM.\n\nThe DELIVERABLE is a playable game in a web browser. The user opens demo/rogue/rogue-wasm/www/index.html, and Rogue runs — rendered as classic ASCII in an 80x24 terminal grid, compiled from Rust to WebAssembly via wasm-pack.\n\nRequirements:\n- Exact mechanical port: same dungeon generation algorithms, monster stats, item tables, RNG seed behavior. 1:1 Rust translation of all C game logic.\n- Full scope: dungeon gen, combat, all item types (14 potions, 18 scrolls, 14 rings, 14 sticks, 9 weapons, 8 armors), 26 monster types with chase AI, save/load (localStorage), scoring, wizard mode, options, daemon/fuse scheduling.\n- Build target: Rust -> WASM via wasm-pack + wasm-bindgen (--target web), served from a single HTML page.\n- Rendering: classic ASCII terminal — '@' player, '#' corridors, '.' floors, monster letters A-Z. 80 columns x 24 rows. Monospace font, dark background. Keyboard input for all commands.\n- The C source is at demo/rogue/original-rogue/ (~16,800 lines across 33 .c files).\n\nSource structure (demo/rogue/original-rogue/):\n  Core: main.c (396L), command.c (820L), rogue.h (753L), extern.h (197L), extern.c (391L)\n  Dungeon: rooms.c (472L), passages.c (424L), new_level.c (231L)\n  Combat: fight.c (686L), weapons.c (288L), armor.c (89L)\n  Items: potions.c (375L), scrolls.c (329L), rings.c (204L), sticks.c (431L), things.c (713L)\n  Monsters: monsters.c (252L), chase.c (541L), daemon.c (181L), daemons.c (295L)\n  Player: move.c (425L), pack.c (503L), list.c (113L)\n  UI/IO: io.c (277L), rip.c (449L), options.c (501L)\n  State: state.c (2134L), save.c (390L), init.c (447L)\n  Platform: mach_dep.c (457L), mdport.c (1432L)\n  Misc: misc.c (597L), wizard.c (284L), xcrypt.c (707L), vers.c (17L)\n\nDisambiguation / Assumptions:\n- ncurses is replaced by a WASM-exported API consumed by a JS terminal renderer in index.html.\n- The C THING union becomes a Rust enum. Global state becomes a GameState struct.\n- Save/load uses serde + localStorage (no filesystem).\n- No networking — single-player browser game.\n- The final artifact is: demo/rogue/rogue-wasm/www/index.html that loads pkg/rogue_wasm.js + .wasm.\n\nExpand into a detailed spec covering:\n1. Project layout (Cargo.toml, src/ modules, www/ HTML+JS+CSS)\n2. Rust module map (C files -> Rust modules)\n3. Core type definitions\n4. WASM bridge API (exported functions, JS->Rust event flow)\n5. Terminal renderer spec (80x24 grid, char rendering, color, keyboard handling)\n6. RNG porting strategy (exact C formula reproduction)\n7. System-by-system porting notes\n8. Build pipeline: cargo build --lib, wasm-pack build --target web, then open www/index.html\n9. Test plan: cargo test (unit tests per module), wasm-pack test --headless --chrome\n10. QA acceptance criteria: the game loads in a browser, you can move with hjkl, fight monsters, pick up items, go down stairs, and die with a tombstone\n\nWrite the spec to .ai/spec.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success"
    ]

    // =========================================================================
    // Phase 2: C source analysis
    // =========================================================================

    impl_analysis [
        shape=box,
        class="hard",
        max_agent_turns=60,
        prompt="Goal: $goal\n\nPerform a deep analysis of the entire Rogue C source at demo/rogue/original-rogue/.\n\nRead EVERY .c and .h file. Catalog:\n1. All data structures (structs, unions, typedefs) with field-level detail\n2. All global variables (from extern.c, extern.h, rogue.h) — name, type, initial value, which files read/write them\n3. All #define constants and macros — gameplay constants (MAXROOMS=9, AMULETLEVEL=26, HUNGERTIME=1300, etc.) and convenience macros (when, otherwise, until, ce, hero, pstats, on(), winat, INDEX, chat, flat, moat)\n4. Every function signature grouped by source file, with brief description\n5. Cross-file dependency graph\n6. The ncurses API surface — every ncurses call used and where (mvaddch, move, refresh, getch, WINDOW, waddch, etc.)\n7. Game loop: main() -> playit() -> command() -> do_daemons/do_fuses -> monster turns\n8. Memory patterns (linked list attach/detach, new_item/discard)\n9. RNG: seed = seed*11109+13849, RN macro = (seed >> 16) & 0xffff, rnd(range), roll(n,s), spread(nm)\n10. Platform code in mach_dep.c/mdport.c that needs WASM equivalents vs. can be dropped\n\nWrite the complete analysis to .ai/rogue_analysis.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if analysis is complete, outcome=fail with failure_reason and details otherwise."
    ]

    verify_analysis [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify the C source analysis is comprehensive and accurate.\n\nRead .ai/rogue_analysis.md. Cross-check against actual C source at demo/rogue/original-rogue/:\n\n1. All 33 .c files covered (list each and confirm present in analysis)\n2. All structs from rogue.h documented (THING, PLACE, room, stats, monster, obj_info, h_list, coord, delayed_action)\n3. All globals from extern.c listed (44+ bools, 10+ strings, 15+ ints)\n4. Spot-check 5 functions for accuracy:\n   a. fight() in fight.c — verify parameter list and description\n   b. do_rooms() in rooms.c — verify algorithm description\n   c. chase() in chase.c — verify AI description\n   d. do_pot() in potions.c — verify potion count\n   e. rs_save_file() in state.c — verify serialization scope\n5. ncurses API surface complete (mvaddch, getch, refresh, addch, move, clrtoeol, etc.)\n6. RNG algorithm correctly documented: seed*11109+13849, >>16, &0xffff\n\nWrite results to .ai/verify_analysis.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if comprehensive and accurate, outcome=fail with failure_reason and details listing specific gaps."
    ]

    check_analysis [shape=diamond, label="Analysis OK?"]

    // =========================================================================
    // Phase 3: Architecture design
    // =========================================================================

    impl_architecture [
        shape=box,
        class="hard",
        max_agent_turns=50,
        prompt="Goal: $goal\n\nRead .ai/spec.md and .ai/rogue_analysis.md.\n\nDesign the Rust/WASM architecture. Write .ai/rogue_architecture.md:\n\n1. **Rust Module Layout** (all under demo/rogue/rogue-wasm/src/):\n   lib.rs — #[wasm_bindgen] exports, WASM entry\n   types.rs — Coord, Thing enum, Place, Room, Stats, Monster, ObjInfo, all constants, bitflags\n   rng.rs — exact C RNG port\n   game.rs — GameState struct (all globals), game loop\n   dungeon.rs — rooms, passages, new_level, maze\n   combat.rs — fight, hit/miss, damage, saving throws\n   items.rs — potions, scrolls, rings, sticks, weapons, armor, things, inventory\n   monsters.rs — monster table, chase AI, spawn\n   daemon.rs — daemon/fuse scheduling, specific daemons\n   player.rs — movement, commands, look, search, traps\n   io_bridge.rs — message system, status line (replaces ncurses I/O)\n   state.rs — save/load via serde + localStorage\n   init.rs — initialization, random names/colors/materials\n   score.rs — death screen, tombstone, scoring\n   wizard.rs — wizard mode\n\n2. **Type Mappings**: THING union -> enum Thing { Monster{..}, Object{..} }; globals -> GameState fields; WINDOW -> screen buffer [Cell; 80*24]; C macros -> const/fn; bit flags -> bitflags!\n\n3. **WASM Bridge**: new_game(seed) -> Game; Game.process_key(key) returns JSON {screen: [[{ch,fg,bg}]], message: str, status: str, game_over: bool}; Game.save_to_storage(); Game.load_from_storage()\n\n4. **JS Terminal Renderer** (in www/index.html):\n   - 80x24 <pre> grid or CSS grid of <span> elements\n   - document.onkeydown -> game.process_key(e.key)\n   - Render loop: parse JSON screen, update DOM spans\n   - Color map: curses COLOR_RED/GREEN/etc. -> CSS colors\n\n5. **ncurses Replacement**: mvaddch -> screen_buf[y][x] = Cell; refresh -> noop (JS reads buffer after process_key); getch -> key passed in from JS; all output buffered, returned per-turn\n\n6. **Cross-Module Interfaces**: exact function signatures each module exports, so subsequent implementation nodes can code against them independently\n\n7. **Build & Serve**: wasm-pack build --target web produces pkg/; www/index.html loads pkg/rogue_wasm.js; open www/index.html in browser to play\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if architecture is complete, outcome=fail with failure_reason and details otherwise."
    ]

    verify_architecture [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify architecture design is complete and consistent.\n\nRead .ai/rogue_architecture.md and .ai/rogue_analysis.md.\n\n1. Every C file has a Rust module assignment (33 files -> 15 modules)\n2. Every C struct has a Rust type mapping\n3. WASM bridge covers all gameplay interactions (new game, process key, save, load)\n4. ncurses replacement covers all used ncurses functions listed in analysis\n5. Cross-module interfaces defined (function signatures for each module boundary)\n6. Build pipeline is clear: wasm-pack build --target web, then open www/index.html\n7. No circular module dependencies\n8. GameState struct accounts for all globals from extern.c\n\nWrite results to .ai/verify_architecture.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if architecture is complete, outcome=fail with failure_reason and details listing specific gaps."
    ]

    check_architecture [shape=diamond, label="Arch OK?"]

    // =========================================================================
    // Phase 4: Scaffold project + core types + RNG
    // =========================================================================

    impl_scaffold [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=2,
        prompt="Goal: $goal\n\nRead .ai/spec.md and .ai/rogue_architecture.md.\n\nCreate the Rust/WASM project at demo/rogue/rogue-wasm/:\n\n1. **.gitignore**: target/, pkg/, wasm-pack.log, *.wasm (build artifacts must not be committed)\n\n2. **Cargo.toml**:\n   [package] name=\"rogue-wasm\", edition=\"2021\"\n   [lib] crate-type=[\"cdylib\",\"rlib\"]\n   [dependencies] wasm-bindgen=\"0.2\", web-sys={version=\"0.3\",features=[\"Window\",\"Document\",\"Storage\",\"console\"]}, js-sys=\"0.3\", serde={version=\"1\",features=[\"derive\"]}, serde_json=\"1\", bitflags=\"2\"\n   [dev-dependencies] wasm-bindgen-test=\"0.3\"\n\n3. **src/types.rs** — ALL core types from rogue.h:\n   Coord, Stats, Thing enum (Monster/Object variants with all fields), Place, Room, Monster template, ObjInfo, HelpEntry, DelayedAction, Cell (ch+fg+bg for screen)\n   ALL constants: MAXROOMS=9, MAXTHINGS=9, MAXOBJ=9, MAXPACK=23, MAXTRAPS=10, AMULETLEVEL=26, NUMTHINGS=7, MAXPASS=13, NUMLINES=24, NUMCOLS=80, MAXDAEMONS=20\n   All item type IDs (P_CONFUSE..P_LEVIT, S_CONFUSE..S_PROTECT, weapon/armor/ring/stick types)\n   All flag bits via bitflags! (room: ISDARK/ISGONE/ISMAZE; object: ISCURSED/ISKNOW/etc.; creature: CANHUH/ISRUN/ISMEAN/etc.; map: F_PASS/F_SEEN/etc.)\n   Trap types, display chars (PASSAGE='#', DOOR='+', FLOOR='.', PLAYER='@', etc.)\n\n4. **src/rng.rs** — EXACT C RNG:\n   pub struct Rng { seed: i32 }\n   fn rn(&mut self) -> u16 { self.seed = self.seed.wrapping_mul(11109).wrapping_add(13849); ((self.seed >> 16) & 0xffff) as u16 }\n   fn rnd(&mut self, range: i32) -> i32 { (self.rn() as i32 % range).abs() }\n   fn roll(&mut self, number: i32, sides: i32) -> i32 { sum of number calls to rnd(sides)+1 }\n   fn spread(&mut self, nm: i32) -> i32 { rnd(nm - nm/20 + 1) + nm - nm/10 }\n\n5. **src/game.rs** — GameState struct with ALL globals from extern.c:\n   All bools, strings, ints, level state, rooms array, places grid, player Thing, monster list, object list, daemon list, Rng, screen buffer [Cell; NUMCOLS*NUMLINES]\n\n6. **src/lib.rs** — WASM entry:\n   #[wasm_bindgen] pub struct Game { state: GameState }\n   #[wasm_bindgen] impl Game { pub fn new(seed: u32) -> Game; pub fn process_key(&mut self, key: &str) -> String; pub fn get_screen_json(&self) -> String; pub fn save_game(&self) -> String; pub fn load_game(&mut self, data: &str); }\n   Stub implementations that compile.\n\n7. **Stub modules**: dungeon.rs, combat.rs, items.rs, monsters.rs, daemon.rs, player.rs, io_bridge.rs, state.rs, init.rs, score.rs, wizard.rs — each with comments and empty pub fn stubs matching architecture interfaces.\n\n8. **www/index.html** — THE PLAYABLE WEB PAGE:\n   <!DOCTYPE html> with <pre id=\"terminal\"> styled 80x24, black bg, monospace\n   <script type=\"module\"> imports from ../pkg/rogue_wasm.js\n   On load: init WASM, game = Game.new(Date.now()), render initial screen\n   document.onkeydown: result = game.process_key(mapKey(e)); update terminal grid\n   mapKey: ArrowUp->k, ArrowDown->j, ArrowLeft->h, ArrowRight->l, all other keys pass through\n   Render function: parse JSON screen, set each <span> textContent and color\n\nAfter creating everything, run:\n  cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nMUST compile with zero errors.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if cargo build --lib succeeds, outcome=fail with failure_reason and details (include compiler errors) otherwise."
    ]

    verify_scaffold [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify project scaffold compiles and is structurally correct.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail if formatting issues\n3. Lint scoped to changed Rust files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n   If no changed .rs files, skip lint and note it.\n4. Structural checks:\n   - src/types.rs defines Coord, Thing, Place, Room, Stats, all constants\n   - src/rng.rs has the exact formula: seed*11109+13849, shift right 16, mask 0xffff\n   - src/game.rs defines GameState with screen buffer, rooms, places, player, monsters\n   - src/lib.rs has #[wasm_bindgen] Game with new(), process_key(), get_screen_json()\n   - All 11 stub modules exist (dungeon, combat, items, monsters, daemon, player, io_bridge, state, init, score, wizard)\n   - www/index.html exists with terminal <pre>, WASM import, keyboard handler\n   - Cargo.toml has wasm-bindgen, web-sys, serde, bitflags\n   - .gitignore excludes target/ and pkg/\n5. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, dist/, build/, pkg/, .pytest_cache/, node_modules/, or backup/temp patterns (*.bak, *.tmp, *.orig).\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_scaffold.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all pass, outcome=fail with failure_reason and details."
    ]

    check_scaffold [shape=diamond, label="Scaffold OK?"]

    // =========================================================================
    // Phase 5: Dungeon generation
    // =========================================================================

    impl_dungeon [
        shape=box,
        class="hard",
        max_agent_turns=60,
        max_retries=2,
        prompt="Goal: $goal\n\nPort the dungeon generation system from C to Rust.\n\nRead C source:\n- demo/rogue/original-rogue/rooms.c (472 lines)\n- demo/rogue/original-rogue/passages.c (424 lines)\n- demo/rogue/original-rogue/new_level.c (231 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs\n- .ai/rogue_architecture.md (module interfaces)\n\nImplement demo/rogue/rogue-wasm/src/dungeon.rs — EXACT ports of:\n\n1. do_rooms() — 3x3 grid room generation (rooms laid out in 3 rows x 3 cols), dark/gone/maze rooms, random sizes within grid cells\n2. draw_room() — wall drawing using horiz()/vert(), floor fill with FLOOR char\n3. horiz() / vert() — border line drawing\n4. door() — place doors on room edges (1-2 per side, on wall positions)\n5. do_passages() — corridor connection algorithm linking room exits\n6. conn() — connect two rooms via recursive corridor path-finding\n7. add_pass() / passnum() / numpass() — passage numbering/identification\n8. new_level() — full level gen orchestrator: clear map, do_rooms(), do_passages(), place stairs, generate objects via create_obj, distribute traps/gold\n9. do_maze() / accnt_maze() — maze generation for ISMAZE rooms\n10. treas_room() — treasure room with extra items and monsters\n11. rnd_room() — random non-gone room selector\n12. find_floor() — find empty floor position in room or level\n\nAll algorithms must be EXACT mechanical ports — same constants, same randomization sequence, same grid layout. Use GameState.rng for all random calls. Write to GameState.places and GameState.rooms.\n\nAlso write at least 3 #[cfg(test)] unit tests:\n- test_rng_determinism: same seed produces same rnd() sequence\n- test_room_generation: do_rooms with fixed seed produces valid rooms (all within bounds, non-zero sizes for non-gone rooms)\n- test_new_level: new_level produces a map with stairs, at least one non-gone room, valid places grid\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 && cargo test 2>&1\n\nWrite implementation log to .ai/port_dungeon.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details (include compiler/test errors) otherwise."
    ]

    verify_dungeon [
        shape=box,
        class="verify",
        max_agent_turns=24,
        prompt="Verify dungeon generation port is correct and faithful to C source.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test dungeon 2>&1 — all dungeon tests must pass\n5. Fidelity spot-checks (compare src/dungeon.rs against C source):\n   a. do_rooms() matches rooms.c 3x3 grid layout with MAXROOMS=9\n   b. conn() matches passages.c corridor algorithm\n   c. new_level() initialization sequence matches new_level.c (clear, rooms, passages, stairs, objects, traps)\n   d. Maze generation matches rooms.c do_maze()\n   e. Constants: room grid cell sizes, min/max room dimensions\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_dungeon.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_dungeon [shape=diamond, label="Dungeon OK?"]

    // =========================================================================
    // Phase 6A: Combat core
    // =========================================================================

    impl_combat_core [
        shape=box,
        class="hard",
        max_agent_turns=42,
        max_retries=2,
        prompt="Goal: $goal\n\nPort the combat core from C to Rust.\n\nRead C source:\n- demo/rogue/original-rogue/fight.c (686 lines)\n- demo/rogue/original-rogue/weapons.c (288 lines)\n- demo/rogue/original-rogue/armor.c (89 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs, src/dungeon.rs\n- .ai/rogue_architecture.md\n\nImplement demo/rogue/rogue-wasm/src/combat.rs with exact ports of:\n- fight() — full melee resolution: to-hit roll, damage, special monster attacks\n- attack() — player attacks monster at position\n- hit_monster() — resolve hit at grid position\n- swing() — to-hit roll formula: at_lvl - op_arm + wplus\n- roll_em() — dice parser and roller (\"2d6+3\" format from damage strings)\n- hit() / miss() — combat message formatting\n- bounce() / fire_bolt() — bolt projectile physics for wand bolts (fire, cold, lightning)\n- killed() — monster death: award XP, drop items, check_level\n- thunk() — thrown weapon impact messages\n- save_throw() — saving throw: d20 vs (10 - level/2)\n- check_level() / raise_level() — XP threshold table and level-up\n- is_magic() — check if item is magical\n\nTests (at least 2 in combat.rs):\n- test_roll_em: verify dice parsing \"2d6\" gives [2,12], \"1d4\" gives [1,4]\n- test_swing: verify to-hit calculation matches C formula with known inputs\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test combat 2>&1\n\nWrite implementation log to .ai/port_combat_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_combat_core [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify combat core port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test combat 2>&1 — tests must pass\n5. Fidelity spot-checks against C source:\n   a. fight()/swing()/roll_em() match fight.c formulas\n   b. Weapon damage strings match weapons.c table\n   c. Armor AC values match armor.c table (leather=8, ring=7, ... plate=2)\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_combat_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_combat_core [shape=diamond, label="Combat Core OK?"]

    // =========================================================================
    // Phase 6B: Item systems
    // =========================================================================

    impl_items_core [
        shape=box,
        class="hard",
        max_agent_turns=42,
        max_retries=2,
        prompt="Goal: $goal\n\nPort the item systems from C to Rust.\n\nRead C source:\n- demo/rogue/original-rogue/potions.c (375 lines)\n- demo/rogue/original-rogue/scrolls.c (329 lines)\n- demo/rogue/original-rogue/rings.c (204 lines)\n- demo/rogue/original-rogue/sticks.c (431 lines)\n- demo/rogue/original-rogue/things.c (713 lines)\n- demo/rogue/original-rogue/weapons.c (288 lines)\n- demo/rogue/original-rogue/armor.c (89 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs, src/combat.rs, src/dungeon.rs\n- .ai/rogue_architecture.md\n\nImplement demo/rogue/rogue-wasm/src/items.rs with exact ports of:\n- Static data tables with EXACT probability weights from things.c:\n  pot_info[14] (confuse, LSD, poison, strength, see-invisible, healing, monster-detect, magic-detect, raise, extra-healing, haste, restore, blindness, levitation)\n  scr_info[18] (confuse, map, hold, sleep, armor, id-potion, id-scroll, id-weapon, id-armor, id-ring, scare, food-detect, teleport, enchant, create-monster, remove-curse, aggravate, protect)\n  ring_info[14], ws_info[14], weap_info[9], arm_info[8], things[7]\n- new_thing() / pick_one() — weighted random item generation\n- inv_name() / nameit() / choose_str() / vowelstr() — item name formatting\n- do_pot() — all 14 potion effects\n- quaff() — drink potion handler\n- read_scroll() — all 18 scroll effects\n- ring_on() / ring_off() / ring_eat() / ring_num() — ring equip/unequip/effects\n- do_zap() / fix_stick() — wand/staff activation and charge management\n- missile() / do_motion() / fall() — thrown weapon trajectory\n- drop() / dropcheck() — drop item from inventory\n- eat() — food consumption and hunger reset\n- wear() / take_off() — armor equip/unequip\n- wield() — weapon equip\n- current() — describe currently equipped items\n- whatis() / identify() / call() / call_it() — item identification system\n- init_weapon() — weapon stat initialization\n- add_pack() / pack_room() / leave_pack() / inventory() / pick_up() — full pack management\n- money() / set_know() / set_order() / pick_color() / charge_str() / num()\n\nTests (at least 2 in items.rs):\n- test_pick_one: weighted selection from things[] produces valid item types\n- test_item_counts: all 14 potions, 18 scrolls, 14 rings, 14 sticks can be generated\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test items 2>&1\n\nWrite implementation log to .ai/port_items_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_items_core [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify item system port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test items 2>&1 — tests must pass\n5. Fidelity spot-checks against C source:\n   a. All 14 potion effects match potions.c do_pot() switch cases\n   b. All 18 scroll effects match scrolls.c read_scroll() switch cases\n   c. pot_info/scr_info/ring_info/ws_info probability tables match things.c EXACTLY\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_items_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_items_core [shape=diamond, label="Items OK?"]

    // =========================================================================
    // Phase 7A: Monster table and chase AI
    // =========================================================================

    impl_monster_ai [
        shape=box,
        class="hard",
        max_agent_turns=42,
        max_retries=2,
        prompt="Goal: $goal\n\nPort monster tables and chase AI from C to Rust.\n\nRead C source:\n- demo/rogue/original-rogue/monsters.c (252 lines)\n- demo/rogue/original-rogue/chase.c (541 lines)\n- demo/rogue/original-rogue/misc.c (find_dest, rndmove, relocate, aggravate, set_oldch)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs, src/dungeon.rs, src/combat.rs, src/items.rs\n- .ai/rogue_architecture.md\n\nImplement demo/rogue/rogue-wasm/src/monsters.rs with exact ports of:\n- MONSTERS static: all 26 types (A-Z) with exact stats from monsters[] table:\n  name, carry%, flags, STR, EXP, LVL, AC, HP dice, damage strings\n  E.g. 'A' aquator carry=0 ISMEAN, 'D' dragon carry=100 ISMEAN dmg=\"1d8/1d8/3d10\",\n  'E' emu carry=0 ISMEAN, 'M' medusa carry=40 ISMEAN|CANHUH, 'V' vampire carry=20 ISMEAN|ISREGEN\n- new_monster() — create monster from template, set stats, place on map\n- randmonster() — level-appropriate random selection (higher level monsters at deeper levels)\n- wanderer() — spawn wandering monster in random room\n- wake_monster() — wake sleeping monster on player room entry\n- give_pack() — random monster inventory based on carry%\n- see_monst() / set_mname() — visibility and naming\n- remove_mon() — remove monster from level (unlink from monster list, clear map position)\n- chase() / do_chase() / runto() / move_monst() / diag_ok() / cansee() / dist() / dist_cp() / turn_ok()\n- find_dest() / rndmove() / relocate() / aggravate() / set_oldch()\n\nTests (at least 2 in monsters.rs):\n- test_monster_table: all 26 entries A-Z with expected key flags/values\n- test_randmonster_progression: deeper levels bias higher-level monsters\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test monster 2>&1\n\nWrite implementation log to .ai/port_monster_ai.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_monster_ai [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify monster table and chase AI port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test monster 2>&1 — tests must pass\n5. Fidelity spot-checks against C source:\n   a. All 26 monster entries match monsters.c table exactly (spot-check A, D, E, M, V, Z)\n   b. chase()/do_chase() behavior matches chase.c\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_monster_ai.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_monster_ai [shape=diamond, label="Monster AI OK?"]

    // =========================================================================
    // Phase 7B: Daemon and fuse scheduler
    // =========================================================================

    impl_daemon_core [
        shape=box,
        class="hard",
        max_agent_turns=36,
        max_retries=2,
        prompt="Goal: $goal\n\nPort daemon and fuse scheduling from C to Rust.\n\nRead C source:\n- demo/rogue/original-rogue/daemon.c (181 lines)\n- demo/rogue/original-rogue/daemons.c (295 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/rng.rs, src/monsters.rs\n- .ai/rogue_architecture.md\n\nImplement demo/rogue/rogue-wasm/src/daemon.rs with exact ports of:\n- d_list: [DelayedAction; MAXDAEMONS] stored in GameState\n- Scheduling API from daemon.c:\n  start_daemon(func, arg, type) / kill_daemon(func)\n  do_daemons(flag) — execute due daemons matching flag (BEFORE/AFTER)\n  fuse(func, arg, time, type) / lengthen(func, add_time) / extinguish(func)\n  do_fuses(flag) — decrement and fire due fuses\n- Specific daemon implementations from daemons.c:\n  runners(), doctor(), stomach(), swander(), come_down(), unconfuse(), unsee(), sight(), visuals(), nohaste(), land(), rollwand()\n- Timing constants and behavior:\n  HEALTIME=30 base; doctor heals 1 HP per (21-level) turns with minimum 3\n  HUNGERTIME=1300, MORETIME=150, STOMACHSIZE=2000, STARVETIME=850\n  stomach transitions at 300 (hungry), 150 (weak), 0 (faint)\n  WANDERTIME=spread(70)\n\nTests (at least 2 in daemon.rs):\n- test_daemon_lifecycle: start_daemon/do_daemons/kill_daemon behavior\n- test_hunger_system: stomach transitions through hungry/weak/faint thresholds\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test daemon 2>&1\n\nWrite implementation log to .ai/port_daemon_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_daemon_core [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify daemon and fuse scheduler port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test daemon 2>&1 — tests must pass\n5. Fidelity spot-checks against C source:\n   a. daemon scheduling (start_daemon/fuse/do_daemons/do_fuses) matches daemon.c\n   b. Hunger timing matches daemons.c stomach() (1300 / 300 / 150 / 0)\n   c. HP regen matches daemons.c doctor() (1 HP per (21-level), min 3)\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_daemon_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_daemon_core [shape=diamond, label="Daemon OK?"]

    // =========================================================================
    // Phase 8A: Player commands and IO bridge
    // =========================================================================

    impl_player_io_core [
        shape=box,
        class="hard",
        max_agent_turns=42,
        max_retries=2,
        prompt="Goal: $goal\n\nPort player command handling and IO bridge from C to Rust. All I/O goes through the WASM bridge, not ncurses.\n\nRead C source:\n- demo/rogue/original-rogue/move.c (425 lines)\n- demo/rogue/original-rogue/command.c (820 lines)\n- demo/rogue/original-rogue/io.c (277 lines)\n- demo/rogue/original-rogue/misc.c (relevant helpers)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/monsters.rs, src/items.rs, src/combat.rs, src/dungeon.rs, src/daemon.rs\n- .ai/rogue_architecture.md\n\nImplement TWO files:\n\n**src/player.rs** — from command.c/move.c/misc.c:\n- command(key) — full key dispatch: h/j/k/l/y/u/b/n movement, H/J/K/L/Y/U/B/N running, . wait, > down stairs, < up stairs, e eat, q quaff, r read scroll, w wield, W wear armor, T take off armor, P put on ring, R remove ring, d drop, c call/name item, D list discovered items, i inventory, s search, z zap wand, t throw, f fight-to-death, ? help, / identify char, ^R redraw, Q quit, S save, ! shell (noop in WASM)\n- do_move(dy, dx) / do_run(dy, dx)\n- look(), enter_room(), leave_room(), erase_lamp(), search(), be_trapped(), door_open(), teleport(), d_level(), u_level()\n- help(), show_map(), show_win(), status(), waste_time(), illcom()\n\n**src/io_bridge.rs** — from io.c with screen buffer output:\n- msg(text) / addmsg(text) / endmsg() with --More-- behavior\n- status() line format: \"Level: %d  Hits: %d(%d)  Str: %d(%d)  Gold: %d  Armor: %d  Exp: %d/%d\"\n- readchar() from GameState key queue\n- wait_for(ch)\n- output writes into GameState.screen [Cell; NUMCOLS*NUMLINES]\n\nTests (at least 2):\n- test_command_dispatch: key bindings map to expected actions\n- test_message_buffering: msg/addmsg/endmsg preserve expected output behavior\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test player io 2>&1\n\nWrite implementation log to .ai/port_player_io_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_player_io_core [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify player command and IO bridge port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test player io 2>&1 — tests must pass\n5. Fidelity spot-checks against C source:\n   a. command() dispatches all keys listed in command.c (30+ bindings)\n   b. do_move() matches move.c movement logic\n   c. Message system matches io.c msg()/addmsg()/endmsg()\n   d. Status line format matches C: \"Level: %d  Hits: %d(%d)  Str: %d(%d)  Gold: %d  Armor: %d  Exp: %d/%d\"\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_player_io_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_player_io_core [shape=diamond, label="Player+IO OK?"]

    // =========================================================================
    // Phase 8B: State persistence
    // =========================================================================

    impl_state_persistence [
        shape=box,
        class="hard",
        max_agent_turns=30,
        max_retries=2,
        prompt="Goal: $goal\n\nPort save/load state persistence from C to Rust/WASM.\n\nRead C source:\n- demo/rogue/original-rogue/save.c (390 lines)\n- demo/rogue/original-rogue/state.c (2134 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/player.rs, src/daemon.rs, src/items.rs, src/monsters.rs\n- .ai/rogue_architecture.md\n\nImplement demo/rogue/rogue-wasm/src/state.rs:\n- save_game(&GameState) -> String — serialize full state via serde_json\n- load_game(data: &str) -> Result<GameState, _> — deserialize\n- Must serialize/restore: rooms, places, player, monsters, items, daemon list, RNG seed, bool/int globals, current level, inventory/equipment, hunger state\n- WASM model: JS owns localStorage; Rust handles encode/decode and structural integrity checks\n\nTests (at least 2):\n- test_save_load_roundtrip: modified GameState survives roundtrip identically\n- test_save_load_rng_seed: RNG seed restoration is exact\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test state 2>&1\n\nWrite implementation log to .ai/port_state_persistence.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_state_persistence [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify state persistence port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test state 2>&1 — tests must pass\n5. Fidelity checks:\n   a. save/load coverage includes all core state domains listed in save.c/state.c\n   b. Roundtrip preserves level, position, HP, inventory, RNG seed\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_state_persistence.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_state_persistence [shape=diamond, label="State OK?"]

    // =========================================================================
    // Phase 8C: Init, scoring, wizard mode
    // =========================================================================

    impl_init_score_wizard [
        shape=box,
        class="hard",
        max_agent_turns=36,
        max_retries=2,
        prompt="Goal: $goal\n\nPort init/options, scoring, and wizard-mode systems from C to Rust.\n\nRead C source:\n- demo/rogue/original-rogue/init.c (447 lines)\n- demo/rogue/original-rogue/options.c (501 lines)\n- demo/rogue/original-rogue/rip.c (449 lines)\n- demo/rogue/original-rogue/wizard.c (284 lines)\n- demo/rogue/original-rogue/rogue.h\n\nRead Rust project:\n- demo/rogue/rogue-wasm/src/types.rs, src/game.rs, src/items.rs, src/player.rs, src/state.rs\n- .ai/rogue_architecture.md\n\nImplement THREE files:\n\n**src/init.rs**:\n- init_player() — STR 16, HP 12, LVL 1, AC 10 (ring mail base 7), EXP 0, starting mace+ring mail+food\n- init_colors(), init_stones(), init_materials(), init_names(), init_probs()\n- parse_opts() / option() core option behaviors for WASM configuration\n\n**src/score.rs**:\n- death(monster_type), total_winner(), score()\n- Tombstone ASCII art faithfully reproduced from rip.c\n- WASM-compatible score persistence behavior\n\n**src/wizard.rs**:\n- create_obj(), show_map(), teleport(), wizard command helpers\n- passwd() behavior\n\nTests (at least 2):\n- test_init_player_stats: STR/HP/LVL/starting gear match C defaults\n- test_tombstone_render: critical tombstone lines are present in output\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test init score wizard 2>&1\n\nWrite implementation log to .ai/port_init_score_wizard.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if compiles and tests pass, outcome=fail with failure_reason and details otherwise."
    ]

    verify_init_score_wizard [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify init/options, scoring, and wizard-mode port is correct and faithful.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test init score wizard 2>&1 — tests must pass\n5. Fidelity checks:\n   a. init_player() stats/equipment match init.c\n   b. Tombstone ASCII art and death/winner flow match rip.c intent\n   c. Wizard-mode helpers map to wizard.c behavior\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_init_score_wizard.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass and port is faithful, outcome=fail with failure_reason and details."
    ]

    check_init_score_wizard [shape=diamond, label="Init/Score/Wizard OK?"]

    // =========================================================================
    // Phase 9A: Integration loop and cross-module wiring
    // =========================================================================

    impl_integration_loop [
        shape=box,
        class="hard",
        max_agent_turns=40,
        max_retries=2,
        prompt="Goal: $goal\n\nAll subsystem ports are complete. Integrate game loop and cross-module behavior in Rust core.\n\nRead:\n- .ai/rogue_architecture.md\n- .ai/port_dungeon.md\n- .ai/port_combat_core.md\n- .ai/port_items_core.md\n- .ai/port_monster_ai.md\n- .ai/port_daemon_core.md\n- .ai/port_player_io_core.md\n- .ai/port_state_persistence.md\n- .ai/port_init_score_wizard.md\n- all files in demo/rogue/rogue-wasm/src/\n\nImplement integration wiring in Rust core:\n1. Main game loop in src/game.rs matching C turn sequence:\n   new_game(seed): init RNG -> init_player() -> init_colors/stones/materials/names/probs -> new_level(1) -> start_daemon(runners) -> start_daemon(doctor) -> fuse(stomach, HUNGERTIME) -> fuse(swander, WANDERTIME)\n   process_key(key): look() -> status() -> command(key) -> do_daemons(BEFORE) -> do_fuses(BEFORE) -> move_monst() -> do_daemons(AFTER) -> do_fuses(AFTER) -> update screen buffer\n2. Resolve cross-module calls:\n   - new_level() calls new_monster(), put_things(), add gold, place traps\n   - command() dispatches to combat/items/dungeon/player APIs\n   - killed() calls give_pack(), awards XP, invokes check_level()\n   - Daemon callbacks trigger chase/heal/hunger behaviors\n   - Ring effects apply during relevant actions\n3. Resolve borrow/lifetime issues without changing behavior semantics\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n- cd demo/rogue/rogue-wasm && cargo test 2>&1\n\nWrite integration log to .ai/integration_loop_log.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if build/tests pass and wiring is complete, outcome=fail with failure_reason and details otherwise."
    ]

    verify_integration_loop [
        shape=box,
        class="verify",
        max_agent_turns=22,
        prompt="Verify integration loop and core wiring are correct.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test 2>&1 — tests must pass\n5. Verify game loop order in game.rs:\n   look -> status -> command -> daemons(BEFORE) -> fuses(BEFORE) -> move_monst -> daemons(AFTER) -> fuses(AFTER)\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_integration_loop.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass, outcome=fail with failure_reason and details."
    ]

    check_integration_loop [shape=diamond, label="Core Integration OK?"]

    // =========================================================================
    // Phase 9B: WASM bridge and browser frontend
    // =========================================================================

    impl_wasm_frontend [
        shape=box,
        class="hard",
        max_agent_turns=36,
        max_retries=2,
        prompt="Goal: $goal\n\nComplete WASM bridge and browser frontend so Rogue is playable from www/index.html.\n\nRead:\n- .ai/rogue_architecture.md\n- .ai/integration_loop_log.md\n- demo/rogue/rogue-wasm/src/lib.rs, src/game.rs, src/state.rs\n- demo/rogue/rogue-wasm/www/index.html\n\nImplement:\n1. src/lib.rs WASM bridge:\n   #[wasm_bindgen] Game wrapper\n   new(seed: u32) -> Game (full init chain)\n   process_key(&mut self, key: &str) -> String JSON with screen/message/status/game_over\n   save_game(&self) -> String\n   load_game(&mut self, data: &str)\n2. www/index.html fully playable UI:\n   - 80x24 terminal grid\n   - keyboard mapping for movement and action keys\n   - render loop from process_key JSON output\n   - color mapping for curses-like colors\n   - game over handling and restart affordance\n   - save/load trigger to localStorage\n3. Build artifacts:\n   - wasm-pack build --target web\n   - verify pkg/ contains rogue_wasm.js and rogue_wasm_bg.wasm\n\nRun:\n- cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1\n- cd demo/rogue/rogue-wasm && cargo test 2>&1\n\nWrite integration log to .ai/wasm_frontend_log.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if wasm build/tests pass and frontend is wired, outcome=fail with failure_reason and details otherwise."
    ]

    verify_wasm_frontend [
        shape=box,
        class="verify",
        max_agent_turns=22,
        prompt="Verify WASM bridge and browser frontend are correct.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1 — must succeed\n5. ls demo/rogue/rogue-wasm/pkg/ — must contain rogue_wasm.js and rogue_wasm_bg.wasm\n6. Verify www/index.html:\n   - Imports from ../pkg/rogue_wasm.js\n   - Has terminal grid\n   - Has keyboard handler and key mapping\n   - Parses JSON screen data and renders\n   - Calls WASM init()\n7. Verify Game exports: new(), process_key(), save_game(), load_game()\n8. cd demo/rogue/rogue-wasm && cargo test 2>&1 — tests pass\n9. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_wasm_frontend.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass, outcome=fail with failure_reason and details."
    ]

    check_wasm_frontend [shape=diamond, label="WASM Frontend OK?"]

    // =========================================================================
    // Phase 10A: QA core fidelity suites
    // =========================================================================

    impl_qa_core [
        shape=box,
        class="hard",
        max_agent_turns=36,
        max_retries=2,
        prompt="Goal: $goal\n\nAdd core fidelity tests and verify correctness against C behavior.\n\nRead: .ai/rogue_analysis.md and all demo/rogue/rogue-wasm/src/ files.\n\nAdd tests for:\n1. RNG fidelity:\n   - Seed=42, call rnd(100) 20 times, compare to values derived from C formula (seed=seed*11109+13849; rn=(seed>>16)&0xffff; rnd=rn%range)\n2. Dungeon generation:\n   - deterministic layout for fixed seed\n   - bounds checks\n   - passage connectivity across non-gone rooms\n   - stairs present on each level\n3. Monster table integrity:\n   - 26 monsters A-Z\n   - spot-check D/E/A stats\n4. Combat math:\n   - swing formula, roll_em ranges, save_throw behavior, XP threshold checks\n5. Item generation:\n   - pick_one distribution sanity\n   - all potion/scroll/ring/stick classes generatable\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo test 2>&1\n\nWrite results to .ai/qa_core_results.md with pass/fail per category.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if core QA tests pass, outcome=fail with failure_reason and details listing each failure."
    ]

    verify_qa_core [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify core QA suite coverage and outcomes.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib --tests -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test 2>&1 — capture full output\n5. Check .ai/qa_core_results.md includes categories 1-5 and explicit pass/fail entries\n6. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_qa_core.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass, outcome=fail with failure_reason and details."
    ]

    check_qa_core [shape=diamond, label="QA Core OK?"]

    // =========================================================================
    // Phase 10B: Runtime/integration QA suites
    // =========================================================================

    impl_qa_runtime [
        shape=box,
        class="hard",
        max_agent_turns=30,
        max_retries=2,
        prompt="Goal: $goal\n\nAdd runtime/integration QA suites and produce final QA summary.\n\nRead:\n- .ai/qa_core_results.md\n- all demo/rogue/rogue-wasm/src/ files\n\nAdd tests for:\n6. Game loop integration:\n   - fixed-seed game, key sequence [\".\", \"l\", \"l\", \"j\", \"j\", \".\"], verify '@' moves and status updates\n7. Save/load roundtrip:\n   - move/pick-up state survives save_game() -> load_game()\n8. Hunger progression:\n   - turns advance through satisfied -> hungry (300) -> weak (150) -> faint (0)\n\nRun:\n- cd demo/rogue/rogue-wasm && cargo test 2>&1\n- cd demo/rogue/rogue-wasm && wasm-pack test --node 2>&1 || echo \"wasm-pack test skipped (no headless browser)\"\n\nWrite consolidated QA report to .ai/qa_results.md with all 8 categories and pass/fail status.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if runtime QA passes and consolidated report is complete, outcome=fail with failure_reason and details listing each failure."
    ]

    verify_qa_runtime [
        shape=box,
        class="verify",
        max_agent_turns=20,
        prompt="Verify runtime/integration QA suite and consolidated report.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1 — must succeed\n2. cd demo/rogue/rogue-wasm && cargo fmt --all -- --check 2>&1 — fail on formatting issues\n3. Lint scoped to changed files:\n   changed=$(git diff --name-only $base_sha -- '*.rs')\n   if [ -n \"$changed\" ]; then cd demo/rogue/rogue-wasm && cargo clippy --lib --tests -- -D warnings 2>&1; fi\n4. cd demo/rogue/rogue-wasm && cargo test 2>&1 — capture full output\n5. cd demo/rogue/rogue-wasm && wasm-pack test --node 2>&1 || echo \"wasm-pack test unavailable\"\n6. Check .ai/qa_results.md includes categories 1-8 and summary totals\n7. Artifact hygiene: fail if git diff --name-only $base_sha includes paths under target/, pkg/, dist/, build/, or backup/temp patterns.\n\nIMPORTANT: Do NOT lint the entire repo. Only check demo/rogue/rogue-wasm.\n\nWrite results to .ai/verify_qa_runtime.md (include totals: passed/failed/skipped).\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if all checks pass, outcome=fail with failure_reason and details."
    ]

    check_qa_runtime [shape=diamond, label="QA Runtime OK?"]

    // =========================================================================
    // Phase 11: Final review
    // =========================================================================

    review [
        shape=box,
        class="review",
        goal_gate=true,
        max_agent_turns=50,
        prompt="Goal: $goal\n\nFinal review of the complete Rogue C-to-Rust/WASM port.\n\nRead:\n- .ai/spec.md\n- .ai/rogue_analysis.md\n- .ai/rogue_architecture.md\n- .ai/port_combat_core.md\n- .ai/port_items_core.md\n- .ai/port_monster_ai.md\n- .ai/port_daemon_core.md\n- .ai/port_player_io_core.md\n- .ai/port_state_persistence.md\n- .ai/port_init_score_wizard.md\n- .ai/integration_loop_log.md\n- .ai/wasm_frontend_log.md\n- .ai/qa_results.md\nRead all files in demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/index.html.\n\nReview checklist:\n1. WASM deliverable: run cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1; verify pkg has .wasm + .js and index loads renderer.\n2. Completeness: cross-reference .ai/rogue_analysis.md and ensure all 33 C files are represented in Rust modules.\n3. Fidelity spot-checks:\n   a. RNG: seed*11109+13849 >> 16 & 0xffff\n   b. Room gen: 3x3 grid, MAXROOMS=9\n   c. Monster table: 26 entries (spot-check E/M/V/D)\n   d. Combat formulas: swing(), roll_em()\n   e. Hunger thresholds: 300/150/0\n   f. HP regen: 1 HP per (21-level), min 3\n   g. S_TELEP behavior\n   h. P_HASTE behavior\n   i. T_ARROW damage\n   j. XP table prefixes [10,20,40,80,160,320,640,1300,2600,5200,...]\n4. Browser playability: keyboard handling, 80x24 rendering, game-over handling, save/load localStorage.\n5. QA: verify .ai/qa_results.md and .ai/verify_qa_runtime.md show 0 critical failures.\n6. Missing features: wizard mode, save/load, scoring, options, full item/monster catalog.\n7. Build verification:\n   cd demo/rogue/rogue-wasm && cargo test 2>&1\n   cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1\n\nSandboxed validation policy:\n- Required checks scoped to demo/rogue/rogue-wasm only.\n- Repo-wide network-dependent checks are advisory only.\n\nWrite detailed review to .ai/final_review.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write status.json in nested module directories after cd.\nWrite status JSON: outcome=success if port is complete, faithful, and playable, outcome=fail with failure_reason and details listing specific issues to fix."
    ]

    check_review [shape=diamond, label="Review OK?"]

    // =========================================================================
    // Edges — fully linear pipeline
    // =========================================================================

    // Toolchain gate
    start -> check_toolchain
    check_toolchain -> expand_spec [condition="outcome=success"]

    // Spec -> Analysis
    expand_spec -> impl_analysis
    impl_analysis -> verify_analysis -> check_analysis
    check_analysis -> impl_architecture     [condition="outcome=success"]
    check_analysis -> impl_analysis         [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_analysis -> impl_analysis         [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Architecture
    impl_architecture -> verify_architecture -> check_architecture
    check_architecture -> impl_scaffold     [condition="outcome=success"]
    check_architecture -> impl_architecture [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_architecture -> impl_architecture [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Scaffold
    impl_scaffold -> verify_scaffold -> check_scaffold
    check_scaffold -> impl_dungeon          [condition="outcome=success"]
    check_scaffold -> impl_scaffold         [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_scaffold -> impl_scaffold         [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Dungeon
    impl_dungeon -> verify_dungeon -> check_dungeon
    check_dungeon -> impl_combat_core       [condition="outcome=success"]
    check_dungeon -> impl_dungeon           [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_dungeon -> impl_dungeon           [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Combat core
    impl_combat_core -> verify_combat_core -> check_combat_core
    check_combat_core -> impl_items_core    [condition="outcome=success"]
    check_combat_core -> impl_combat_core   [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_combat_core -> impl_combat_core   [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Item systems
    impl_items_core -> verify_items_core -> check_items_core
    check_items_core -> impl_monster_ai     [condition="outcome=success"]
    check_items_core -> impl_items_core     [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_items_core -> impl_items_core     [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Monster AI
    impl_monster_ai -> verify_monster_ai -> check_monster_ai
    check_monster_ai -> impl_daemon_core    [condition="outcome=success"]
    check_monster_ai -> impl_monster_ai     [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_monster_ai -> impl_monster_ai     [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Daemon scheduler
    impl_daemon_core -> verify_daemon_core -> check_daemon_core
    check_daemon_core -> impl_player_io_core [condition="outcome=success"]
    check_daemon_core -> impl_daemon_core    [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_daemon_core -> impl_daemon_core    [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Player + IO
    impl_player_io_core -> verify_player_io_core -> check_player_io_core
    check_player_io_core -> impl_state_persistence [condition="outcome=success"]
    check_player_io_core -> impl_player_io_core    [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_player_io_core -> impl_player_io_core    [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // State persistence
    impl_state_persistence -> verify_state_persistence -> check_state_persistence
    check_state_persistence -> impl_init_score_wizard [condition="outcome=success"]
    check_state_persistence -> impl_state_persistence [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_state_persistence -> impl_state_persistence [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Init + Score + Wizard
    impl_init_score_wizard -> verify_init_score_wizard -> check_init_score_wizard
    check_init_score_wizard -> impl_integration_loop      [condition="outcome=success"]
    check_init_score_wizard -> impl_init_score_wizard     [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_init_score_wizard -> impl_init_score_wizard     [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Integration loop
    impl_integration_loop -> verify_integration_loop -> check_integration_loop
    check_integration_loop -> impl_wasm_frontend          [condition="outcome=success"]
    check_integration_loop -> impl_integration_loop       [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_integration_loop -> impl_integration_loop       [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // WASM frontend
    impl_wasm_frontend -> verify_wasm_frontend -> check_wasm_frontend
    check_wasm_frontend -> impl_qa_core                  [condition="outcome=success"]
    check_wasm_frontend -> impl_wasm_frontend            [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_wasm_frontend -> impl_wasm_frontend            [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // QA core
    impl_qa_core -> verify_qa_core -> check_qa_core
    check_qa_core -> impl_qa_runtime                     [condition="outcome=success"]
    check_qa_core -> impl_qa_core                        [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_qa_core -> impl_qa_core                        [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // QA runtime
    impl_qa_runtime -> verify_qa_runtime -> check_qa_runtime
    check_qa_runtime -> review                           [condition="outcome=success"]
    check_qa_runtime -> impl_qa_runtime                  [condition="outcome=fail && context.failure_class=transient_infra", label="retry-infra", loop_restart=true]
    check_qa_runtime -> impl_qa_runtime                  [condition="outcome=fail && context.failure_class!=transient_infra", label="retry"]

    // Final review — failure loops to late integration
    review -> check_review
    check_review -> exit                                 [condition="outcome=success"]
    check_review -> impl_integration_loop                [condition="outcome=fail && context.failure_class=transient_infra", label="fix-infra", loop_restart=true]
    check_review -> impl_integration_loop                [condition="outcome=fail && context.failure_class!=transient_infra", label="fix"]
}
