digraph rogue_port {
    graph [
        goal="Port the classic Rogue 5.4.4 game from C to Rust compiled to WebAssembly, playable in a browser. The original C source is at demo/rogue/original-rogue/ — about 16,800 lines across 33 files. The deliverable is a single HTML page at demo/rogue/rogue-wasm/www/index.html with classic ASCII terminal rendering: 80x24 grid, @ player, # corridors, monster letters A-Z, dark background, monospace font. This must be an exact mechanical port — same dungeon generation algorithms, same monster stats and AI, same item tables, same RNG formula, same combat math — a faithful 1:1 translation of every game system. ncurses I/O gets replaced by a WASM bridge to a JS terminal renderer, and save/load uses localStorage instead of the filesystem.",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: gemini-3-flash-preview; llm_provider: google; }
            .hard { llm_model: gemini-3-flash-preview; llm_provider: google; }
            .verify { llm_model: gemini-3-flash-preview; llm_provider: google; }
            .branch-a { llm_model: gemini-3-flash-preview; llm_provider: google; }
            .branch-b { llm_model: gemini-3-flash-preview; llm_provider: google; }
            .branch-c { llm_model: gemini-3-flash-preview; llm_provider: google; }
        "
    ]

    exit  [shape=Msquare, label="Exit"]

    subgraph cluster_bootstrap {
        label="Bootstrap"
        start [shape=Mdiamond, label="Start"]

        check_toolchain [
            shape=parallelogram,
            max_retries=0,
            tool_command="/Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/rustc --version && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo --version && /Users/jonathan/.cargo/bin/wasm-pack --version"
        ]

        expand_spec [
            shape=box,
            auto_status=true,
            prompt="You are creating the canonical specification for a Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
1. Check if .ai/spec.md already exists and is adequate:
   - If it exists and covers the scope, deliverables, constraints, and acceptance criteria for this Rogue port, keep it as-is
   - If it's a placeholder or inadequate, proceed to step 2

2. If creating a new spec, examine the original Rogue source structure at demo/rogue/original-rogue/ to understand:
   - The 33 C source files and their organization
   - Core systems: dungeon generation, monster AI, item handling, combat, RNG
   - ncurses I/O patterns that need WASM/JS bridge replacement
   - File I/O patterns that need localStorage replacement

3. Write .ai/spec.md with these sections:
   ## Scope
   - Port Rogue 5.4.4 from C to Rust/WASM
   - Exact mechanical translation (algorithms, stats, tables, formulas)
   - Browser playable via single HTML page

   ## Deliverables
   - demo/rogue/rogue-wasm/www/index.html (playable page)
   - Rust source organized in demo/rogue/rogue-wasm/src/
   - WASM binary compiled from Rust
   - JS glue code for terminal rendering and localStorage

   ## Core Requirements
   ### Faithful Port
   - Same dungeon generation algorithm as original C
   - Same monster stats, AI behavior, and movement
   - Same item tables and effects
   - Same RNG formula
   - Same combat math

   ### Terminal Rendering
   - 80x24 character grid
   - Classic ASCII: @ for player, # for corridors, A-Z for monsters
   - Dark background, monospace font
   - Render via JS terminal emulator

   ### Platform Adaptation
   - Replace ncurses calls with WASM→JS bridge for terminal I/O
   - Replace C file I/O with localStorage for save/load
   - Keyboard input via JS event handlers

   ## Constraints
   - Must preserve exact game mechanics (no gameplay changes)
   - Single-page application (no server required)
   - Must work in modern browsers (Chrome, Firefox, Safari, Edge)

   ## Assumptions
   - Original C source at demo/rogue/original-rogue/ is authoritative
   - Browser has WASM support
   - localStorage available for save files

   ## Non-Goals
   - Not adding new features or game modes
   - Not modernizing graphics (keep ASCII)
   - Not supporting mobile/touch (keyboard only)
   - Not multiplayer or networking

OUTPUT:
Write .ai/spec.md with the above structure. Include the full user-provided goal verbatim in a delimited block:

---BEGIN-VERBATIM-GOAL---
$goal
---END-VERBATIM-GOAL---

Status: This node has auto_status=true, so no explicit status write is needed."
        ]

        check_dod [
            shape=box,
            label="DoD exists?",
            prompt="Check if .ai/definition_of_done.md exists and is adequate for the Rogue port project.

GOAL:
$goal

YOUR TASK:
1. Check if .ai/definition_of_done.md exists
2. If it exists, verify it contains:
   - Specific deliverables (HTML page path, Rust source structure)
   - Acceptance criteria for faithful port (dungeon gen, monster AI, combat, RNG, items)
   - Verification approach (how to test mechanical correctness)
   - Build/test requirements
   - Quality gates (formatting, no artifacts, WASM bundle size)
   - Non-goals

3. Determine outcome:
   - If DoD exists and covers all Rogue port requirements → outcome=has_dod
   - If DoD missing or inadequate → outcome=needs_dod

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\",\"outcome\":\"has_dod\"} or {\"status\":\"success\",\"outcome\":\"needs_dod\"}.

Do NOT write nested status.json files after cd commands. Use only the provided status path variables."
        ]
    }

    subgraph cluster_dod {
        label="DoD Fanout"
        node [shape=box]

        dod_fanout [shape=component, label="DoD Fan-Out"]

        dod_a [
            class="branch-a",
            prompt="Create a Definition of Done for the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
Read .ai/spec.md to understand the project scope and requirements.

Write .ai/dod_a.md with these sections:

## Scope
List what's in scope: faithful port of Rogue 5.4.4 C code to Rust/WASM, browser playable, single HTML page deliverable.

## Deliverables
1. demo/rogue/rogue-wasm/www/index.html - playable single-page application
2. demo/rogue/rogue-wasm/src/ - Rust source modules
3. WASM binary and JS glue code
4. Build system (Cargo.toml, wasm-pack config)

## Acceptance Criteria
### AC1: Faithful Port - Dungeon Generation
- Dungeon layout algorithm matches original C implementation
- Room placement, corridor generation, door placement identical
- Verifiable: side-by-side dungeon generation comparison

### AC2: Faithful Port - Monster AI
- All monsters (A-Z) present with original stats (HP, attack, defense)
- Monster movement and pathfinding matches original behavior
- Verifiable: monster behavior matches original

### AC3: Faithful Port - Combat System
- Damage calculation formula matches original
- Hit/miss mechanics identical
- Verifiable: combat math produces same results as C version

### AC4: Faithful Port - Item System
- All item types present (weapons, armor, potions, scrolls, rings, food)
- Item effects match original
- Verifiable: item interactions match original

### AC5: Faithful Port - RNG
- Random number generator uses same algorithm as original
- Same seed produces same game sequence
- Verifiable: deterministic replay with fixed seed

### AC6: Terminal Rendering
- 80x24 character grid
- ASCII characters: @ player, # corridors, + doors, . floor, | and - walls, A-Z monsters
- Dark background, monospace font
- Verifiable: visual inspection of rendered game

### AC7: Save/Load
- Save game state to browser localStorage
- Load restores exact game state
- Verifiable: save/load cycle preserves all state

### AC8: Browser Playability
- Works in Chrome, Firefox, Safari, Edge (latest versions)
- Keyboard input responds correctly
- No server required
- Verifiable: manual testing in each browser

## Verification Approach
1. Build verification: cargo build succeeds, wasm-pack build succeeds
2. Functional verification: game runs in browser, accepts input, renders correctly
3. Mechanical correctness: compare game mechanics against original C source
4. Cross-browser testing: verify in 4 major browsers

## Quality Gates
- Rust code passes cargo fmt check
- No .cargo-target* or .cargo_target* directories in repo
- WASM bundle under 2MB
- No console errors in browser

## Non-Goals
- Not adding new features
- Not modernizing UI beyond basic ASCII
- Not supporting mobile/touch
- Not implementing multiplayer

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        dod_b [
            class="branch-b",
            prompt="Create a Definition of Done for the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
Read .ai/spec.md to understand the project scope and requirements.

Write .ai/dod_b.md with these sections:

## Scope
List what's in scope: faithful port of Rogue 5.4.4 C code to Rust/WASM, browser playable, single HTML page deliverable.

## Deliverables
1. demo/rogue/rogue-wasm/www/index.html - playable single-page application
2. demo/rogue/rogue-wasm/src/ - Rust source modules
3. WASM binary and JS glue code
4. Build system (Cargo.toml, wasm-pack config)

## Acceptance Criteria
### AC1: Faithful Port - Dungeon Generation
- Dungeon layout algorithm matches original C implementation
- Room placement, corridor generation, door placement identical
- Verifiable: side-by-side dungeon generation comparison

### AC2: Faithful Port - Monster AI
- All monsters (A-Z) present with original stats (HP, attack, defense)
- Monster movement and pathfinding matches original behavior
- Verifiable: monster behavior matches original

### AC3: Faithful Port - Combat System
- Damage calculation formula matches original
- Hit/miss mechanics identical
- Verifiable: combat math produces same results as C version

### AC4: Faithful Port - Item System
- All item types present (weapons, armor, potions, scrolls, rings, food)
- Item effects match original
- Verifiable: item interactions match original

### AC5: Faithful Port - RNG
- Random number generator uses same algorithm as original
- Same seed produces same game sequence
- Verifiable: deterministic replay with fixed seed

### AC6: Terminal Rendering
- 80x24 character grid
- ASCII characters: @ player, # corridors, + doors, . floor, | and - walls, A-Z monsters
- Dark background, monospace font
- Verifiable: visual inspection of rendered game

### AC7: Save/Load
- Save game state to browser localStorage
- Load restores exact game state
- Verifiable: save/load cycle preserves all state

### AC8: Browser Playability
- Works in Chrome, Firefox, Safari, Edge (latest versions)
- Keyboard input responds correctly
- No server required
- Verifiable: manual testing in each browser

## Verification Approach
1. Build verification: cargo build succeeds, wasm-pack build succeeds
2. Functional verification: game runs in browser, accepts input, renders correctly
3. Mechanical correctness: compare game mechanics against original C source
4. Cross-browser testing: verify in 4 major browsers

## Quality Gates
- Rust code passes cargo fmt check
- No .cargo-target* or .cargo_target* directories in repo
- WASM bundle under 2MB
- No console errors in browser

## Non-Goals
- Not adding new features
- Not modernizing UI beyond basic ASCII
- Not supporting mobile/touch
- Not implementing multiplayer

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        dod_c [
            class="branch-c",
            prompt="Create a Definition of Done for the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:
Read .ai/spec.md to understand the project scope and requirements.

Write .ai/dod_c.md with these sections:

## Scope
List what's in scope: faithful port of Rogue 5.4.4 C code to Rust/WASM, browser playable, single HTML page deliverable.

## Deliverables
1. demo/rogue/rogue-wasm/www/index.html - playable single-page application
2. demo/rogue/rogue-wasm/src/ - Rust source modules
3. WASM binary and JS glue code
4. Build system (Cargo.toml, wasm-pack config)

## Acceptance Criteria
### AC1: Faithful Port - Dungeon Generation
- Dungeon layout algorithm matches original C implementation
- Room placement, corridor generation, door placement identical
- Verifiable: side-by-side dungeon generation comparison

### AC2: Faithful Port - Monster AI
- All monsters (A-Z) present with original stats (HP, attack, defense)
- Monster movement and pathfinding matches original behavior
- Verifiable: monster behavior matches original

### AC3: Faithful Port - Combat System
- Damage calculation formula matches original
- Hit/miss mechanics identical
- Verifiable: combat math produces same results as C version

### AC4: Faithful Port - Item System
- All item types present (weapons, armor, potions, scrolls, rings, food)
- Item effects match original
- Verifiable: item interactions match original

### AC5: Faithful Port - RNG
- Random number generator uses same algorithm as original
- Same seed produces same game sequence
- Verifiable: deterministic replay with fixed seed

### AC6: Terminal Rendering
- 80x24 character grid
- ASCII characters: @ player, # corridors, + doors, . floor, | and - walls, A-Z monsters
- Dark background, monospace font
- Verifiable: visual inspection of rendered game

### AC7: Save/Load
- Save game state to browser localStorage
- Load restores exact game state
- Verifiable: save/load cycle preserves all state

### AC8: Browser Playability
- Works in Chrome, Firefox, Safari, Edge (latest versions)
- Keyboard input responds correctly
- No server required
- Verifiable: manual testing in each browser

## Verification Approach
1. Build verification: cargo build succeeds, wasm-pack build succeeds
2. Functional verification: game runs in browser, accepts input, renders correctly
3. Mechanical correctness: compare game mechanics against original C source
4. Cross-browser testing: verify in 4 major browsers

## Quality Gates
- Rust code passes cargo fmt check
- No .cargo-target* or .cargo_target* directories in repo
- WASM bundle under 2MB
- No console errors in browser

## Non-Goals
- Not adding new features
- Not modernizing UI beyond basic ASCII
- Not supporting mobile/touch
- Not implementing multiplayer

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        consolidate_dod [
            prompt="Synthesize the three DoD proposals (dod_a, dod_b, dod_c) into a single consensus Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read branch outputs:
   - First, check if parallel_results.json exists and use worktree_dir to locate branch outputs
   - If parallel_results.json is missing, fall back to reading from current worktree
   - Read .ai/dod_a.md, .ai/dod_b.md, .ai/dod_c.md

2. Read .ai/spec.md for context

3. Create .ai/definition_of_done.md by:
   - Taking the best elements from each branch proposal
   - Resolving any contradictions
   - Ensuring coverage of DoD rubric: scope, deliverables, acceptance criteria, verification, quality gates, non-goals
   - Ensuring coverage checklist: build (cargo/wasm-pack), tests, formatting, browser compatibility, WASM bundle size

4. DoD must be outcomes/evidence based (pass/fail criteria), not implementation steps

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]
    }

    subgraph cluster_planning {
        label="Planning Fanout"
        node [shape=box]

        plan_fanout [shape=component, label="Plan Fan-Out"]

        plan_a [
            class="branch-a",
            prompt="Create an implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.

GOAL:
$goal

YOUR TASK:
1. Read .ai/spec.md and .ai/definition_of_done.md
2. If .ai/postmortem_latest.md exists, read it and incorporate lessons learned

3. Examine the original C source at demo/rogue/original-rogue/:
   - Identify the 33 C files and their dependencies
   - Map core systems: dungeon gen, monster AI, combat, items, RNG, I/O
   - Note ncurses usage patterns
   - Note file I/O patterns

4. Create .ai/plan_a.md covering all DoD deliverables and acceptance criteria:

   ### Phase 1: Project Setup
   - Initialize Cargo workspace at demo/rogue/rogue-wasm/
   - Configure wasm-pack in Cargo.toml
   - Set up build system for WASM target

   ### Phase 2: Core Data Structures
   - Port C structs to Rust (player, monsters, items, dungeon tiles)
   - Ensure memory layout compatibility where needed
   - Use Rust idioms (Option, Result) for null/error handling

   ### Phase 3: RNG System
   - Port original RNG algorithm from C
   - Verify deterministic behavior (same seed → same sequence)

   ### Phase 4: Dungeon Generation
   - Port room placement algorithm
   - Port corridor generation
   - Port door placement
   - Verify identical layout behavior

   ### Phase 5: Monster System
   - Port monster stats table
   - Port monster AI and pathfinding
   - Port monster movement

   ### Phase 6: Item System
   - Port item type definitions
   - Port item effects
   - Port inventory management

   ### Phase 7: Combat System
   - Port damage calculation
   - Port hit/miss mechanics
   - Verify math matches original

   ### Phase 8: WASM/JS Bridge
   - Replace ncurses with WASM exports for terminal I/O
   - Create JS terminal renderer (80x24 grid, ASCII chars)
   - Wire keyboard input from JS to WASM

   ### Phase 9: localStorage Save/Load
   - Replace C file I/O with localStorage
   - Serialize/deserialize game state

   ### Phase 10: Integration
   - Create demo/rogue/rogue-wasm/www/index.html
   - Wire all systems together
   - Test in multiple browsers

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        plan_b [
            class="branch-b",
            prompt="Create an implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.

GOAL:
$goal

YOUR TASK:
1. Read .ai/spec.md and .ai/definition_of_done.md
2. If .ai/postmortem_latest.md exists, read it and incorporate lessons learned

3. Examine the original C source at demo/rogue/original-rogue/:
   - Identify the 33 C files and their dependencies
   - Map core systems: dungeon gen, monster AI, combat, items, RNG, I/O
   - Note ncurses usage patterns
   - Note file I/O patterns

4. Create .ai/plan_b.md covering all DoD deliverables and acceptance criteria:

   ### Phase 1: Project Setup
   - Initialize Cargo workspace at demo/rogue/rogue-wasm/
   - Configure wasm-pack in Cargo.toml
   - Set up build system for WASM target

   ### Phase 2: Core Data Structures
   - Port C structs to Rust (player, monsters, items, dungeon tiles)
   - Ensure memory layout compatibility where needed
   - Use Rust idioms (Option, Result) for null/error handling

   ### Phase 3: RNG System
   - Port original RNG algorithm from C
   - Verify deterministic behavior (same seed → same sequence)

   ### Phase 4: Dungeon Generation
   - Port room placement algorithm
   - Port corridor generation
   - Port door placement
   - Verify identical layout behavior

   ### Phase 5: Monster System
   - Port monster stats table
   - Port monster AI and pathfinding
   - Port monster movement

   ### Phase 6: Item System
   - Port item type definitions
   - Port item effects
   - Port inventory management

   ### Phase 7: Combat System
   - Port damage calculation
   - Port hit/miss mechanics
   - Verify math matches original

   ### Phase 8: WASM/JS Bridge
   - Replace ncurses with WASM exports for terminal I/O
   - Create JS terminal renderer (80x24 grid, ASCII chars)
   - Wire keyboard input from JS to WASM

   ### Phase 9: localStorage Save/Load
   - Replace C file I/O with localStorage
   - Serialize/deserialize game state

   ### Phase 10: Integration
   - Create demo/rogue/rogue-wasm/www/index.html
   - Wire all systems together
   - Test in multiple browsers

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        plan_c [
            class="branch-c",
            prompt="Create an implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.

GOAL:
$goal

YOUR TASK:
1. Read .ai/spec.md and .ai/definition_of_done.md
2. If .ai/postmortem_latest.md exists, read it and incorporate lessons learned

3. Examine the original C source at demo/rogue/original-rogue/:
   - Identify the 33 C files and their dependencies
   - Map core systems: dungeon gen, monster AI, combat, items, RNG, I/O
   - Note ncurses usage patterns
   - Note file I/O patterns

4. Create .ai/plan_c.md covering all DoD deliverables and acceptance criteria:

   ### Phase 1: Project Setup
   - Initialize Cargo workspace at demo/rogue/rogue-wasm/
   - Configure wasm-pack in Cargo.toml
   - Set up build system for WASM target

   ### Phase 2: Core Data Structures
   - Port C structs to Rust (player, monsters, items, dungeon tiles)
   - Ensure memory layout compatibility where needed
   - Use Rust idioms (Option, Result) for null/error handling

   ### Phase 3: RNG System
   - Port original RNG algorithm from C
   - Verify deterministic behavior (same seed → same sequence)

   ### Phase 4: Dungeon Generation
   - Port room placement algorithm
   - Port corridor generation
   - Port door placement
   - Verify identical layout behavior

   ### Phase 5: Monster System
   - Port monster stats table
   - Port monster AI and pathfinding
   - Port monster movement

   ### Phase 6: Item System
   - Port item type definitions
   - Port item effects
   - Port inventory management

   ### Phase 7: Combat System
   - Port damage calculation
   - Port hit/miss mechanics
   - Verify math matches original

   ### Phase 8: WASM/JS Bridge
   - Replace ncurses with WASM exports for terminal I/O
   - Create JS terminal renderer (80x24 grid, ASCII chars)
   - Wire keyboard input from JS to WASM

   ### Phase 9: localStorage Save/Load
   - Replace C file I/O with localStorage
   - Serialize/deserialize game state

   ### Phase 10: Integration
   - Create demo/rogue/rogue-wasm/www/index.html
   - Wire all systems together
   - Test in multiple browsers

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]

        debate_consolidate [
            prompt="Synthesize the three implementation plans (plan_a, plan_b, plan_c) into a single best-of-breed final plan.

GOAL:
$goal

YOUR TASK:
1. Read branch outputs:
   - First, check if parallel_results.json exists and use worktree_dir to locate branch outputs
   - If parallel_results.json is missing, fall back to reading from current worktree
   - Read .ai/plan_a.md, .ai/plan_b.md, .ai/plan_c.md

2. If .ai/postmortem_latest.md exists, verify the final plan addresses every identified issue

3. Create .ai/plan_final.md by:
   - Taking best approaches from each branch
   - Resolving conflicts between plans
   - Ensuring correct dependency order (RNG before dungeon gen, data structures before algorithms)
   - Covering all DoD deliverables and acceptance criteria
   - Being specific to Rogue port: exact file structure, system organization, WASM/JS interfaces

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema {\"status\":\"success\"} on completion, or {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\"} on failure."
        ]
    }

    subgraph cluster_implement_verify {
        label="Implement And Verify"

        implement [
            shape=box,
            class="hard",
            max_retries=2,
            prompt="Implement the Rogue 5.4.4 C-to-Rust/WASM port.

GOAL:
$goal

YOUR TASK:

**REPAIR MODE CHECK:**
If .ai/postmortem_latest.md exists:
1. Read it FIRST
2. Fix ONLY the identified gaps
3. DO NOT regenerate working systems
4. Preserve all passing code and tests

**FRESH IMPLEMENTATION:**
If no postmortem exists:
1. Read .ai/plan_final.md for implementation approach
2. Read .ai/spec.md and .ai/definition_of_done.md

**IMPLEMENTATION REQUIREMENTS:**

### Project Structure
Create demo/rogue/rogue-wasm/ with:
- Cargo.toml (wasm-pack configuration)
- src/ (Rust modules)
- www/ (HTML/JS/CSS)
- www/index.html (single-page deliverable)

### Module Organization
Organize Rust code by system (match the 33 C files' logical structure):
- src/lib.rs (WASM exports and main loop)
- src/types.rs (core data structures)
- src/rng.rs (RNG port from original C)
- src/dungeon.rs (dungeon generation)
- src/monster.rs (monster AI and stats)
- src/item.rs (item system)
- src/combat.rs (combat mechanics)
- src/io.rs (WASM/JS bridge for terminal I/O)
- src/save.rs (localStorage save/load)

### Faithful Port Requirements
1. **RNG**: Port the exact RNG algorithm from original C
   - Same seed must produce same sequence
   - Verify: test with fixed seed, compare outputs

2. **Dungeon Generation**: Port room placement, corridor generation, door placement algorithms exactly
   - Match original layout behavior
   - Verify: generate dungeons with fixed seeds, compare

3. **Monster System**: Port all monster stats (A-Z), AI, pathfinding, movement
   - Use original stat tables
   - Match original behavior
   - Verify: monster actions match C version

4. **Item System**: Port all item types (weapons, armor, potions, scrolls, rings, food) and effects
   - Use original item tables
   - Match original effects
   - Verify: item interactions match C version

5. **Combat**: Port damage calculation and hit/miss formulas exactly
   - Match original math
   - Verify: combat outcomes match C version

### WASM/JS Bridge
- Export terminal I/O functions from Rust via wasm-bindgen
- Create JS terminal renderer in www/index.html:
  - 80x24 character grid
  - Monospace font (Courier New or similar)
  - Dark background (#000000 or #1a1a1a)
  - ASCII characters: @ player, # corridors, + doors, . floor, | - walls, A-Z monsters
- Wire keyboard input (arrow keys, inventory keys) from JS to WASM

### localStorage Save/Load
- Replace C file I/O with Web Storage API
- Serialize game state to JSON
- Save to localStorage on save command
- Load from localStorage on load command

### Progressive Compilation
- Build each module before starting the next
- Fix compilation errors immediately
- Use cargo check frequently

### Implementation Log
- Log progress to .ai/implementation_log.md
- Note completed modules, remaining work, blockers

**ON FAILURE:**
If implementation fails, include failure_signature in status metadata with specific failed component(s).

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- Success: {\"status\":\"success\"}
- Failure: {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent|transient_infra\",\"meta\":{\"failure_signature\":\"component1,component2\"}}
- Retry: {\"status\":\"retry\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"transient_infra|permanent\"}"
        ]
        check_implement [shape=diamond, label="Implement OK?"]

        fix_fmt [
            shape=parallelogram,
            max_retries=0,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo fmt"
        ]

        verify_fmt [
            shape=parallelogram,
            max_retries=0,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo fmt --check"
        ]
        check_fmt [shape=diamond, label="Fmt OK?"]

        verify_build [
            shape=parallelogram,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo build --target wasm32-unknown-unknown --release && /Users/jonathan/.cargo/bin/wasm-pack build --target web --out-dir www/pkg"
        ]
        check_build [shape=diamond, label="Build OK?"]

        verify_test [
            shape=parallelogram,
            tool_command="cd demo/rogue/rogue-wasm && /Users/jonathan/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo test && test -f www/index.html && test -f www/pkg/rogue_wasm.js && test -f www/pkg/rogue_wasm_bg.wasm"
        ]
        check_test [shape=diamond, label="Tests OK?"]

        verify_artifacts [
            shape=parallelogram,
            max_retries=0,
            tool_command="! find demo/rogue/rogue-wasm -type d \\( -name '.cargo-target*' -o -name '.cargo_target*' \\) | grep -q ."
        ]
        check_artifacts [shape=diamond, label="Artifacts OK?"]

        verify_fidelity [
            shape=box,
            class="verify",
            prompt="Verify the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md and .ai/spec.md

2. Verify each acceptance criterion:

   **AC1: Faithful Port - Dungeon Generation**
   - Check: Does src/dungeon.rs implement the same room placement algorithm as original C?
   - Check: Are corridors generated identically?
   - Check: Are doors placed using the same logic?
   - Evidence: Read src/dungeon.rs and compare to demo/rogue/original-rogue/ dungeon generation code

   **AC2: Faithful Port - Monster AI**
   - Check: Are all monsters A-Z present in src/monster.rs?
   - Check: Do monster stats match original C tables?
   - Check: Does pathfinding match original behavior?
   - Evidence: Read src/monster.rs and compare to original monster code

   **AC3: Faithful Port - Combat System**
   - Check: Does damage calculation in src/combat.rs match original formula?
   - Check: Do hit/miss mechanics match original?
   - Evidence: Read src/combat.rs and compare to original combat code

   **AC4: Faithful Port - Item System**
   - Check: Are all item types present in src/item.rs?
   - Check: Do item effects match original?
   - Evidence: Read src/item.rs and compare to original item code

   **AC5: Faithful Port - RNG**
   - Check: Does src/rng.rs use the same RNG algorithm as original C?
   - Evidence: Read src/rng.rs and compare to original RNG code

   **AC6: Terminal Rendering**
   - Check: Does www/index.html implement 80x24 grid?
   - Check: Are ASCII characters correct (@ player, # corridors, etc.)?
   - Check: Is background dark and font monospace?
   - Evidence: Read www/index.html and verify rendering code

   **AC7: Save/Load**
   - Check: Does src/save.rs implement localStorage save/load?
   - Check: Is game state fully serialized?
   - Evidence: Read src/save.rs

   **AC8: Browser Playability**
   - Check: Does index.html load WASM correctly?
   - Check: Is keyboard input wired up?
   - Evidence: Read www/index.html and verify JS glue code

3. Write detailed verification results to .ai/verify_fidelity.md:
   - List each AC with pass/fail status
   - Provide specific evidence for each
   - If any AC fails, list specific gaps

**ON FAILURE:**
Include failure_signature in status metadata: comma-separated list of failed AC identifiers (e.g., \"AC1,AC3,AC5\").

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- Success: {\"status\":\"success\"}
- Failure: {\"status\":\"fail\",\"failure_reason\":\"...\",\"details\":\"...\",\"failure_class\":\"permanent\",\"meta\":{\"failure_signature\":\"AC1,AC3\"}}"
        ]
        check_impl [shape=diamond, label="Impl OK?"]
    }

    subgraph cluster_review {
        label="Review Fanout"
        node [shape=box]

        review_fanout [shape=component, label="Review Fan-Out"]

        review_a [
            class="branch-a",
            prompt="Review the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md for acceptance criteria

2. Review implementation:
   - Read demo/rogue/rogue-wasm/src/ (all Rust modules)
   - Read demo/rogue/rogue-wasm/www/index.html
   - Read demo/rogue/rogue-wasm/Cargo.toml

3. Check each DoD criterion:
   - **Build**: Does cargo build succeed? Is wasm-pack configured?
   - **Completeness**: Are all systems implemented (dungeon, monsters, combat, items, RNG, I/O, save/load)?
   - **Correctness**: Do algorithms match original C (dungeon gen, monster AI, combat math, RNG)?
   - **Terminal**: Is rendering 80x24 ASCII with correct characters?
   - **Browser**: Is HTML page complete with WASM loading and keyboard input?
   - **Save/Load**: Is localStorage integration complete?

4. Write .ai/review_a.md with:
   - **Verdict**: APPROVED or REJECTED
   - **Evidence**: Specific findings for each criterion
   - If REJECTED: List specific gaps with AC identifiers (e.g., AC1, AC3)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- APPROVED: {\"status\":\"success\"}
- REJECTED: {\"status\":\"fail\",\"failure_reason\":\"gaps in [AC identifiers]\",\"details\":\"specific issues\",\"failure_class\":\"permanent\"}"
        ]

        review_b [
            class="branch-b",
            prompt="Review the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md for acceptance criteria

2. Review implementation:
   - Read demo/rogue/rogue-wasm/src/ (all Rust modules)
   - Read demo/rogue/rogue-wasm/www/index.html
   - Read demo/rogue/rogue-wasm/Cargo.toml

3. Check each DoD criterion:
   - **Build**: Does cargo build succeed? Is wasm-pack configured?
   - **Completeness**: Are all systems implemented (dungeon, monsters, combat, items, RNG, I/O, save/load)?
   - **Correctness**: Do algorithms match original C (dungeon gen, monster AI, combat math, RNG)?
   - **Terminal**: Is rendering 80x24 ASCII with correct characters?
   - **Browser**: Is HTML page complete with WASM loading and keyboard input?
   - **Save/Load**: Is localStorage integration complete?

4. Write .ai/review_b.md with:
   - **Verdict**: APPROVED or REJECTED
   - **Evidence**: Specific findings for each criterion
   - If REJECTED: List specific gaps with AC identifiers (e.g., AC1, AC3)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- APPROVED: {\"status\":\"success\"}
- REJECTED: {\"status\":\"fail\",\"failure_reason\":\"gaps in [AC identifiers]\",\"details\":\"specific issues\",\"failure_class\":\"permanent\"}"
        ]

        review_c [
            class="branch-c",
            prompt="Review the Rogue port implementation against the Definition of Done.

GOAL:
$goal

YOUR TASK:
1. Read .ai/definition_of_done.md for acceptance criteria

2. Review implementation:
   - Read demo/rogue/rogue-wasm/src/ (all Rust modules)
   - Read demo/rogue/rogue-wasm/www/index.html
   - Read demo/rogue/rogue-wasm/Cargo.toml

3. Check each DoD criterion:
   - **Build**: Does cargo build succeed? Is wasm-pack configured?
   - **Completeness**: Are all systems implemented (dungeon, monsters, combat, items, RNG, I/O, save/load)?
   - **Correctness**: Do algorithms match original C (dungeon gen, monster AI, combat math, RNG)?
   - **Terminal**: Is rendering 80x24 ASCII with correct characters?
   - **Browser**: Is HTML page complete with WASM loading and keyboard input?
   - **Save/Load**: Is localStorage integration complete?

4. Write .ai/review_c.md with:
   - **Verdict**: APPROVED or REJECTED
   - **Evidence**: Specific findings for each criterion
   - If REJECTED: List specific gaps with AC identifiers (e.g., AC1, AC3)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- APPROVED: {\"status\":\"success\"}
- REJECTED: {\"status\":\"fail\",\"failure_reason\":\"gaps in [AC identifiers]\",\"details\":\"specific issues\",\"failure_class\":\"permanent\"}"
        ]

        review_consensus [
            goal_gate=true,
            prompt="Synthesize the three reviews (review_a, review_b, review_c) into a consensus verdict.

GOAL:
$goal

YOUR TASK:
1. Read branch outputs:
   - First, check if parallel_results.json exists and use worktree_dir to locate branch outputs
   - If parallel_results.json is missing, fall back to reading from current worktree
   - Read .ai/review_a.md, .ai/review_b.md, .ai/review_c.md

2. Read .ai/definition_of_done.md for criteria

3. Apply consensus rule:
   - If 2+ reviews are APPROVED with no critical gaps → **SUCCESS**
   - If 1 or fewer APPROVED, or critical gaps identified → **RETRY** with specific issues

4. Write .ai/review_consensus.md with:
   - **Consensus Verdict**: SUCCESS or RETRY
   - **Summary**: What passed, what needs fixing
   - If RETRY: Specific issues to address (with AC identifiers)

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- SUCCESS: {\"status\":\"success\",\"outcome\":\"success\"}
- RETRY: {\"status\":\"fail\",\"failure_reason\":\"issues found\",\"details\":\"specific gaps\",\"failure_class\":\"permanent\"}"
        ]
    }

    subgraph cluster_postmortem {
        label="Postmortem"
        node [shape=box]

        postmortem [
            prompt="Analyze the implementation failure and guide the next repair iteration.

GOAL:
$goal

YOUR TASK:
1. Read failure context:
   - If review stage reached: read .ai/review_consensus.md
   - If semantic verify ran: read .ai/verify_fidelity.md
   - If branch reviews available: check parallel_results.json + worktree_dir for .ai/review_a.md, .ai/review_b.md, .ai/review_c.md
   - Read .ai/implementation_log.md

2. Identify:
   - **Root causes**: Why did implementation fail?
   - **What worked**: Which systems are passing? (PRESERVE THESE)
   - **What failed**: Which systems/ACs failed? (FIX THESE)
   - **Concrete next changes**: Specific repairs needed

3. Classify failure for recovery routing:
   - **impl_repair**: Code needs fixing, plan/toolchain still valid (DEFAULT)
   - **needs_replan**: Plan/approach is fundamentally inadequate
   - **needs_toolchain**: Environment/toolchain issue detected

4. Write .ai/postmortem_latest.md (overwrite previous) with:
   - Root cause analysis
   - What to preserve (passing code)
   - What to fix (specific modules/functions)
   - Concrete repair instructions

**CRITICAL**: DO NOT direct from-scratch restart. Preserve working code.

OUTPUT STATUS:
Write to $KILROY_STAGE_STATUS_PATH (or fall back to $KILROY_STAGE_STATUS_FALLBACK_PATH if unavailable) with JSON schema:
- {\"status\":\"success\",\"outcome\":\"impl_repair\"} (default, code repair needed)
- {\"status\":\"success\",\"outcome\":\"needs_replan\"} (plan inadequate)
- {\"status\":\"success\",\"outcome\":\"needs_toolchain\"} (toolchain issue)

Note: status=success means postmortem analysis completed successfully, NOT that implementation succeeded."
        ]
    }

    // Flow
    start -> check_toolchain
    check_toolchain -> expand_spec [condition="outcome=success"]
    check_toolchain -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_toolchain -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_toolchain -> postmortem
    expand_spec -> check_dod

    check_dod -> dod_fanout [condition="outcome=needs_dod"]
    check_dod -> dod_fanout
    dod_fanout -> dod_a
    dod_fanout -> dod_b
    dod_fanout -> dod_c
    dod_a -> consolidate_dod
    dod_b -> consolidate_dod
    dod_c -> consolidate_dod
    consolidate_dod -> plan_fanout

    check_dod -> plan_fanout [condition="outcome=has_dod"]

    plan_fanout -> plan_a
    plan_fanout -> plan_b
    plan_fanout -> plan_c
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement

    implement -> check_implement
    check_implement -> fix_fmt [condition="outcome=success"]
    fix_fmt -> verify_fmt
    check_implement -> implement  [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_implement -> postmortem
    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> implement    [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem   [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fmt -> postmortem

    verify_build -> check_build
    check_build -> verify_test  [condition="outcome=success"]
    check_build -> implement    [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem   [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_build -> postmortem

    verify_test -> check_test
    check_test -> verify_artifacts [condition="outcome=success"]
    check_test -> implement        [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem       [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_test -> postmortem

    verify_artifacts -> check_artifacts
    check_artifacts -> verify_fidelity [condition="outcome=success"]
    check_artifacts -> implement       [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_artifacts -> postmortem      [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_artifacts -> postmortem

    verify_fidelity -> check_impl
    check_impl -> review_fanout [condition="outcome=success"]
    review_fanout -> review_a
    review_fanout -> review_b
    review_fanout -> review_c
    check_impl -> implement  [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_impl -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_impl -> postmortem

    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem

    postmortem -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra"]
    postmortem -> implement [condition="outcome=impl_repair"]
    postmortem -> plan_fanout [condition="outcome=needs_replan"]
    postmortem -> check_toolchain [condition="outcome=needs_toolchain"]
    postmortem -> implement
}